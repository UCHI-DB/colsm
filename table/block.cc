// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.
//
// Decodes the blocks generated by block_builder.cc.

#include "table/block.h"

#include <algorithm>
#include <cstdint>
#include <iostream>
#include <vector>

#include "leveldb/comparator.h"

#include "table/format.h"
#include "util/coding.h"
#include "util/logging.h"

#include "byteutils.h"
#include "sboost.h"
#include "unpacker.h"

namespace leveldb {

inline uint32_t Block::NumRestarts() const {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}

Block::Block(const BlockContents& contents)
    : data_(contents.data.data()),
      size_(contents.data.size()),
      owned_(contents.heap_allocated) {
  if (size_ < sizeof(uint32_t)) {
    size_ = 0;  // Error marker
  } else {
    size_t max_restarts_allowed = (size_ - sizeof(uint32_t)) / sizeof(uint32_t);
    if (NumRestarts() > max_restarts_allowed) {
      // The size is too small for NumRestarts()
      size_ = 0;
    } else {
      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
    }
  }
}

Block::~Block() {
  if (owned_) {
    delete[] data_;
  }
}

// Helper routine: decode the next block entry starting at "p",
// storing the number of shared key bytes, non_shared key bytes,
// and the length of the value in "*shared", "*non_shared", and
// "*value_length", respectively.  Will not dereference past "limit".
//
// If any errors are detected, returns nullptr.  Otherwise, returns a
// pointer to the key delta (just past the three decoded values).
static inline const char* DecodeEntry(const char* p, const char* limit,
                                      uint32_t* shared, uint32_t* non_shared,
                                      uint32_t* value_length) {
  if (limit - p < 3) return nullptr;
  *shared = reinterpret_cast<const uint8_t*>(p)[0];
  *non_shared = reinterpret_cast<const uint8_t*>(p)[1];
  *value_length = reinterpret_cast<const uint8_t*>(p)[2];
  if ((*shared | *non_shared | *value_length) < 128) {
    // Fast path: all three values are encoded in one byte each
    p += 3;
  } else {
    if ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) return nullptr;
    if ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr) return nullptr;
    if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) return nullptr;
  }

  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
    return nullptr;
  }
  return p;
}

class Block::Iter : public Iterator {
 private:
  const Comparator* const comparator_;
  const char* const data_;       // underlying block contents
  uint32_t const restarts_;      // Offset of restart array (list of fixed32)
  uint32_t const num_restarts_;  // Number of uint32_t entries in restart array

  // current_ is offset in data_ of current entry.  >= restarts_ if !Valid
  uint32_t current_;
  uint32_t restart_index_;  // Index of restart block in which current_ falls
  std::string key_;
  Slice value_;
  Status status_;

  inline int Compare(const Slice& a, const Slice& b) const {
    return comparator_->Compare(a, b);
  }

  // Return the offset in data_ just past the end of the current entry.
  inline uint32_t NextEntryOffset() const {
    return (value_.data() + value_.size()) - data_;
  }

  uint32_t GetRestartPoint(uint32_t index) {
    assert(index < num_restarts_);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }

  void SeekToRestartPoint(uint32_t index) {
    key_.clear();
    restart_index_ = index;
    // current_ will be fixed by ParseNextKey();

    // ParseNextKey() starts at the end of value_, so set value_ accordingly
    uint32_t offset = GetRestartPoint(index);
    value_ = Slice(data_ + offset, 0);
  }

 public:
  Iter(const Comparator* comparator, const char* data, uint32_t restarts,
       uint32_t num_restarts)
      : comparator_(comparator),
        data_(data),
        restarts_(restarts),
        num_restarts_(num_restarts),
        current_(restarts_),
        restart_index_(num_restarts_) {
    assert(num_restarts_ > 0);
  }

  bool Valid() const override { return current_ < restarts_; }
  Status status() const override { return status_; }
  Slice key() const override {
    assert(Valid());
    return key_;
  }
  Slice value() const override {
    assert(Valid());
    return value_;
  }

  void Next() override {
    assert(Valid());
    ParseNextKey();
  }

  void Prev() override {
    assert(Valid());

    // Scan backwards to a restart point before current_
    const uint32_t original = current_;
    while (GetRestartPoint(restart_index_) >= original) {
      if (restart_index_ == 0) {
        // No more entries
        current_ = restarts_;
        restart_index_ = num_restarts_;
        return;
      }
      restart_index_--;
    }

    SeekToRestartPoint(restart_index_);
    do {
      // Loop until end of current entry hits the start of original entry
    } while (ParseNextKey() && NextEntryOffset() < original);
  }

  void Seek(const Slice& target) override {
    //    std::cout << num_restarts_ << std::endl;
    // Binary search in restart array to find the last restart point
    // with a key < target
    uint32_t left = 0;
    uint32_t right = num_restarts_ - 1;
    auto loop = 0;
    while (left < right) {
      loop++;
      uint32_t mid = (left + right + 1) / 2;
      uint32_t region_offset = GetRestartPoint(mid);
      uint32_t shared, non_shared, value_length;
      const char* key_ptr =
          DecodeEntry(data_ + region_offset, data_ + restarts_, &shared,
                      &non_shared, &value_length);
      if (key_ptr == nullptr || (shared != 0)) {
        CorruptionError();
        return;
      }
      Slice mid_key(key_ptr, non_shared);
      if (Compare(mid_key, target) < 0) {
        // Key at "mid" is smaller than "target".  Therefore all
        // blocks before "mid" are uninteresting.
        left = mid;
      } else {
        // Key at "mid" is >= "target".  Therefore all blocks at or
        // after "mid" are uninteresting.
        right = mid - 1;
      }
    }

    //    std::cout << loop << std::endl;
    // Linear search (within restart block) for first key >= target
    SeekToRestartPoint(left);
    while (true) {
      if (!ParseNextKey()) {
        return;
      }
      if (Compare(key_, target) >= 0) {
        return;
      }
    }
  }

  void SeekToFirst() override {
    SeekToRestartPoint(0);
    ParseNextKey();
  }

  void SeekToLast() override {
    SeekToRestartPoint(num_restarts_ - 1);
    while (ParseNextKey() && NextEntryOffset() < restarts_) {
      // Keep skipping
    }
  }

 private:
  void CorruptionError() {
    current_ = restarts_;
    restart_index_ = num_restarts_;
    status_ = Status::Corruption("bad entry in block");
    key_.clear();
    value_.clear();
  }

  bool ParseNextKey() {
    current_ = NextEntryOffset();
    const char* p = data_ + current_;
    const char* limit = data_ + restarts_;  // Restarts come right after data
    if (p >= limit) {
      // No more entries to return.  Mark as invalid.
      current_ = restarts_;
      restart_index_ = num_restarts_;
      return false;
    }

    // Decode next entry
    uint32_t shared, non_shared, value_length;
    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
    if (p == nullptr || key_.size() < shared) {
      CorruptionError();
      return false;
    } else {
      key_.resize(shared);
      key_.append(p, non_shared);
      value_ = Slice(p + non_shared, value_length);
      while (restart_index_ + 1 < num_restarts_ &&
             GetRestartPoint(restart_index_ + 1) < current_) {
        ++restart_index_;
      }
      return true;
    }
  }
};

Iterator* Block::NewIterator(const Comparator* comparator) {
  if (size_ < sizeof(uint32_t)) {
    return NewErrorIterator(Status::Corruption("bad block contents"));
  }
  const uint32_t num_restarts = NumRestarts();
  if (num_restarts == 0) {
    return NewEmptyIterator();
  } else {
    return new Iter(comparator, data_, restart_offset_, num_restarts);
  }
}

int eq_packed(const uint8_t* data, uint32_t num_entry, uint8_t bitwidth,
              uint32_t target) {
  uint32_t mask = (1 << bitwidth) - 1;
  uint32_t begin = 0;
  uint32_t end = num_entry - 1;
  while (begin <= end) {
    auto current = (begin + end + 1) / 2;

    auto bits = current * bitwidth;
    auto index = bits >> 3;
    auto offset = bits & 0x7;

    auto extracted = (*(uint32_t*)(data + index) >> offset) & mask;

    if (extracted == target) {
      return current;
    }
    if (extracted > target) {
      end = current - 1;
    } else {
      begin = current + 1;
    }
  }
  return -1;
}

int section_packed(uint8_t* data, uint32_t num_entry, uint8_t bitwidth,
                   uint32_t target) {
  uint32_t mask = (1 << bitwidth) - 1;
  uint32_t begin = 0;
  uint32_t end = num_entry - 1;
  while (begin < end) {
    auto current = (begin + end + 1) / 2;

    auto bits = current * bitwidth;
    auto index = bits >> 3;
    auto offset = bits & 0x7;

    auto extracted = (*(uint32_t*)(data + index) >> offset) & mask;

    if (extracted <= target) {
      begin = current;
    } else {
      end = current - 1;
    }
  }
  return begin;
}

VertBlockMeta::VertBlockMeta()
    : num_section_(0), start_min_(0), start_bitwidth_(0), starts_(NULL) {}

VertBlockMeta::~VertBlockMeta() {}

void VertBlockMeta::AddSection(uint64_t offset, int32_t start_value) {
  num_section_++;
  if (starts_plain_.empty()) {
    start_min_ = start_value;
  }
  starts_plain_.push_back(start_value - start_min_);
  offsets_.push_back(offset);
}

uint64_t VertBlockMeta::Search(int32_t value) {
  //  std::cout << num_section_ << "," << (int32_t)start_bitwidth_ << std::endl;
  auto target = value - start_min_;
  //  sboost::SortedBitpack sbp(start_bitwidth_, target);
  //  auto index = sbp.greater(starts_, num_section_);
  //  return offsets_[index - 1];
  return offsets_[section_packed(starts_, num_section_, start_bitwidth_,
                                 target)];
}

uint32_t VertBlockMeta::Read(const char* in) {
  const char* pointer = in;
  num_section_ = *reinterpret_cast<const uint32_t*>(pointer);
  pointer += 4;
  offsets_.resize(num_section_);
  memcpy(offsets_.data(), pointer, num_section_ * 8);
  pointer += num_section_ * 8;
  start_min_ = *reinterpret_cast<const int32_t*>(pointer);
  pointer += 4;
  start_bitwidth_ = *(pointer++);

  starts_ = (uint8_t*)pointer;

  return pointer - in;
}

void VertBlockMeta::Finish() {
  start_bitwidth_ = 32 - _lzcnt_u32(starts_plain_[starts_plain_.size() - 1]);
}

uint32_t VertBlockMeta::EstimateSize() {
  return 9 + num_section_ * 8 + BitPackSize();
}

uint32_t VertBlockMeta::Write(char* out) {
  char* pointer = out;
  *reinterpret_cast<uint32_t*>(pointer) = num_section_;
  pointer += 4;
  memcpy(pointer, offsets_.data(), 8 * num_section_);
  pointer += 8 * num_section_;
  *reinterpret_cast<int32_t*>(pointer) = start_min_;
  pointer += 4;

  *reinterpret_cast<uint8_t*>(pointer++) = start_bitwidth_;
  sboost::byteutils::bitpack(starts_plain_.data(), num_section_,
                             start_bitwidth_, (uint8_t*)pointer);

  //  memcpy(pointer, starts_, (start_bitwidth_ * num_section_ + 7) >> 3);
}

VertSection::VertSection() : num_entry_(0), estimated_size_(0) {}

VertSection::~VertSection() {}

void VertSection::Add(int32_t key, const Slice& value) {
  num_entry_++;
  keys_plain_.push_back(key - start_value_);
  auto size = value.size();
  values_plain_.append((const char*)&size, 4);
  values_plain_.append(value.data(), value.size());
}

uint32_t VertSection::EstimateSize() {
  if (estimated_size_ != 0) {
    return estimated_size_;
  }
  num_entry_ = keys_plain_.size();
  bit_width_ = 32 - _lzcnt_u32(keys_plain_[num_entry_ - 1]);
  estimated_size_ = 9 + BitPackSize() + values_plain_.size();
  return estimated_size_;
}

void VertSection::Write(char* out) {
  auto pointer = out;
  *reinterpret_cast<uint32_t*>(pointer) = num_entry_;
  pointer += 4;
  *reinterpret_cast<int32_t*>(pointer) = start_value_;
  pointer += 4;
  *reinterpret_cast<uint8_t*>(pointer++) = bit_width_;
  sboost::byteutils::bitpack(keys_plain_.data(), keys_plain_.size(), bit_width_,
                             (uint8_t*)pointer);
  pointer += BitPackSize();
  memcpy(pointer, values_plain_.data(), values_plain_.size());
}

void VertSection::Read(const char* in) {
  auto pointer = in;
  num_entry_ = *reinterpret_cast<const uint32_t*>(pointer);
  pointer += 4;
  start_value_ = *reinterpret_cast<const int32_t*>(pointer);
  pointer += 4;
  bit_width_ = *reinterpret_cast<const uint8_t*>(pointer++);
  keys_data_ = reinterpret_cast<const uint8_t*>(pointer);
  pointer += BitPackSize();
  values_data_ = reinterpret_cast<const uint8_t*>(pointer);
  // Recompute estimated size
  // TODO Temporarily ignoring value size here as we do not store it
  estimated_size_ = 9 + BitPackSize();
}

int32_t VertSection::Find(int32_t target) {
  //  sboost::SortedBitpack sbp(bit_width_, target - start_value_);
  //  return sbp.equal(keys_data_, num_entry_);
  return eq_packed(keys_data_, num_entry_, bit_width_, target - start_value_);
}

int32_t VertSection::FindStart(int32_t target) {
  sboost::SortedBitpack sbp(bit_width_, target - start_value_);
  return sbp.geq(keys_data_, num_entry_);
}

VertBlock::VertBlock(const BlockContents& data)
    : data_(data.data.data()),
      size_(data.data.size()),
      owned_(data.heap_allocated) {}

VertBlock::~VertBlock() {
  if (owned_) {
    delete[] data_;
  }
}

class VertBlock::VIter : public Iterator {
 private:
  const Comparator* const comparator_;
  VertBlockMeta meta_;
  const char* data_pointer_;

  sboost::Unpacker* unpacker_;

  int intkey_;
  Slice key_;
  Slice value_;

  Status status_;

 public:
  VIter(const Comparator* comparator, const char* data)
      : comparator_(comparator), key_((const char*)&intkey_, 4) {
    meta_.Read(data);
    data_pointer_ = data + meta_.EstimateSize();
  }

  void Seek(const Slice& target) override {
    // Scan through blocks
    int32_t target_key = *reinterpret_cast<const int32_t*>(target.data());
    auto section_offset = meta_.Search(target_key);

    VertSection section;
    section.Read(data_pointer_ + section_offset);

    auto index = section.Find(target_key);
    if (index == -1) {
      // Not found
      status_ = Status::NotFound(target);
    } else {
      // Seek to the position, extract the keys and values
      // TODO Switch to a reader and maintain current unpacking location
      // Unpack 8 entries at a time, read bit_width_ bytes at a time
      unpacker_ = sboost::unpackers[section.BitWidth()];
      auto group_index = index >> 3;
      auto group_offset = index & 0x7;
      auto group_start = section.KeysData() + group_index * section.BitWidth();
      auto unpacked = unpacker_->unpack(group_start);
      auto entry =
          (unpacked[group_offset / 2] >> (32 * (group_offset & 1))) & -1;
      intkey_ = entry + section.StartValue();

      // Sequential look up value
      const char* value_pointer = (const char*)section.ValuesData();
      for (auto i = 0; i < index; ++i) {
        value_pointer += 4 + *(const uint32_t*)value_pointer;
      }
      value_ = Slice(value_pointer + 4, *(const uint32_t*)value_pointer);
    }
  }

  void SeekToFirst() override {}

  void SeekToLast() override {}

  void Next() override {}

  void Prev() override {}

  bool Valid() const override { return true; }

  Slice key() const override { return key_; }

  Slice value() const override { return value_; }

  Status status() const override {}
};

Iterator* VertBlock::NewIterator(const Comparator* comparator) {
  return new VIter(comparator, data_);
}
}  // namespace leveldb
